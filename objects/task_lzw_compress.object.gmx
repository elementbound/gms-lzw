<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>task_g</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

var i = 0;
st_prematch = i++;
st_match = i++;
st_postmatch = i++;

stage = st_prematch; 
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="12">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(shrink_after)
    buffer_shrink(buff_out); 
  
ds_list_destroy(dictionary); 
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Prematch
if(stage == st_prematch) {
    if(i &gt;= buffer_get_size(buff_in)) {
        done = true;
        progress = 1;
        exit;
    }
    
    progress = i / buffer_get_size(buff_in); 
    
    // Find longest match 
    match_id = -1;
    match_length = -1;
    
    j = 0;
    
    stage++;
    
    exit;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Match
if(stage == st_match) {
    if(j &gt;= ds_list_size(dictionary)-1) {
        stage++;
        exit;
    }
    
    var matched = true; 
    var word = dictionary[|j];
    
    // Word longer than remaining input
    if(i + ds_list_size(word) &gt;= buffer_get_size(buff_in)) {
        // continue; 
        
        j++;
        exit; 
    }
        
    // Check for match
    buffer_seek(buff_in, buffer_seek_start, i); 
    
    for(var k = 0; k &lt; ds_list_size(word); k++) {
        if(word[|k] != buffer_read(buff_in, buffer_u8)) {
            matched = false;
            break;
        }
    }
    
    // Store if matched 
    if(matched &amp;&amp; ds_list_size(word) &gt; match_length) {
        match_id = j;
        match_length = ds_list_size(word); 
    }
    
    j++;

    exit;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Postmatch
if(stage == st_postmatch) {
    if(match_id &gt;= 0) {
        // Output dict ref if matched
        buffer_write(buff_out, buffer_u16, match_id+256);
        
        // Seek buffer, multiple bytes consumed
        i += match_length; 
        buffer_seek(buff_in, buffer_seek_start, i);
        
        // Add new word 
        // ( if we don't overrun the dictionary AND there's an additional byte to read )
        if(ds_list_size(dictionary) &lt; max_dict_size &amp;&amp; i+1 &lt; buffer_get_size(buff_in)) {
            var match_word = dictionary[|match_id];
            var new_word = ds_list_create();
            
            ds_list_copy(new_word, match_word); 
            ds_list_add(new_word, buffer_read(buff_in, buffer_u8));
            
            ds_list_add(dictionary, new_word); 
            ds_list_mark_as_list(dictionary, ds_list_size(dictionary)-1); 
        }
    }
    else {
        // Otherwise output character as-is 
        // Seek buffer
        buffer_seek(buff_in, buffer_seek_start, i);
        
        var byte = buffer_read(buff_in, buffer_u8);
        buffer_write(buff_out, buffer_u16, byte);
        
        // Add new word 
        // ( if we don't overrun the dictionary AND there's an additional byte to read )
        if(ds_list_size(dictionary) &lt; max_dict_size &amp;&amp; i+1 &lt; buffer_get_size(buff_in)) {
            var new_word = ds_list_create();
            ds_list_add(new_word, byte, buffer_read(buff_in, buffer_u8)); 
            
            ds_list_add(dictionary, new_word);
            ds_list_mark_as_list(dictionary, ds_list_size(dictionary)-1); 
        }
        
        // Single byte consumed
        i++;
    }

    // Reset stage
    stage = st_prematch;
    
    exit;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Init
buffer_seek(buff_in, buffer_seek_start, 0);

// TODO: store words in a priority queue sorted by length, so we can start with longest words 
// TODO: this is questionable tho 
dictionary = ds_list_create(); 
max_dict_size = 65536 - 256;

// Work-loop
i = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var expected_size = buffer_tell(buff_out) / progress;
if(done)
    expected_size = buffer_get_size(buff_out); 

var txt = concat("FPS: ", fps, "##",object_get_name(object_index), "#",
                 "Progress: ", progress*100, "%", "#",
                 "Done: ", done, "#",
                 "Time: ", lerp((get_timer()/1000 - start_time), (end_time - start_time), done), " ms#", 
                 "Expected size: ", expected_size, "#",
                 "Compression ratio: ", (expected_size/buffer_get_size(buff_in))*100, "%", "#");
                 
if(!done)
    txt += concat("Dictionary size: ", ds_list_size(dictionary));
                 
draw_text(2,2, txt); 
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
